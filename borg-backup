#!/bin/bash
# SPDX-FileCopyrightText: 2018-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
#/ Wrapper for a deduplicating archiver BorgBackup. It simplifies performing
#/ everyday tasks on multiply repositories.
#/ Homepage: https://github.com/octivi/borg-backup-wrapper/
#/
#/ Usage: borg-backup [-c config file] <command> [archive [path...]]
#/
#/ Commands (borg commands mapped 1:1):
#/   - break-lock|compact|create|check|delete|extract|info|init|list|prune|recreate|with-lock
#/
#/ Commands bundles (executes one after another, with the same environmental settings):
#/   - create+prune|create+prune+check|prune+check
#/
#/ Arguments for command 'create':
#/   - path - paths to archive (required if BORG_PATHS is not set)
#/
#/ Arguments for command 'delete':
#/   - archive - archive to delete (required)
#/
#/ Arguments for command 'extract':
#/   - archive - archive to extract (required)
#/   - path - paths to extract; patterns are supported (optional)
#/   - WARNING: extract always writes into the current working directory ("."), so make sure you changed
#/              directory to the right place before calling borg extract.
#/
#/ Arguments for command 'get-key' (contains sensitive information!):
#/   - path - if repository is accessible, then save BORG_PASSPHRASE and BORG_KEY to this file (optional)
#/
#/ Arguments for command 'list':
#/   - archive - archive to list (required)
#/
#/ Required environmental variables:
#/   - BORG_REPO - the default repository location
#/     https://borgbackup.readthedocs.io/en/stable/usage/general.html#repository-urls
#/   - BORG_PASSPHRASE - the passphrase for encrypted repository
#/
#/ Optional environmental variables:
#/   - OBB_LIB_PATH - path to Octivi Bash Boilerplate library, defaults to '/usr/local/share/octivi-bash-boilerplate'
#/   - BORG_OPTIONS_CREATE - array of additional options to 'create' and 'recreate' commands, defaults to () (empty array)
#/   - BORG_OPTIONS_PRUNE - array of additional options to 'prune' command, defaults to () (empty array)
#/   - BORG_COMPRESSION - defaults to 'lz4'
#/   - BORG_ENCRYPTION - defaults to 'repokey-blake2'
#/   - BORG_ARCHIVE_NAME - defaults to '{now:%Y-%m-%dT%H:%M:%S}'
#/   - BORG_BASE_DIR - defaults to borg defaults
#/   - BORG_CONFIG_DIR - defaults to 'BORG_BASE_DIR/config' if BORG_BASE_DIR is set
#/   - BORG_CACHE_DIR - defaults to 'BORG_BASE_DIR/cache' if BORG_BASE_DIR is set
#/   - BORG_SECURITY_DIR - defaults to 'BORG_BASE_DIR/security' if BORG_BASE_DIR is set
#/   - BORG_KEYS_DIR - defaults to 'BORG_BASE_DIR/keys' if BORG_BASE_DIR is set
#/   - BORG_LOG_DIR - defaults to 'BORG_BASE_DIR/logs' if BORG_BASE_DIR is set or empty if BORG_BASE_DIR is not set
#/   - BORG_LOG_FILE - defaults to '<DATE>-<REPO>-<COMMAND>.log'
#/   - BORG_KEEP_WITHIN - defaults to 30 days (if set then overwrites other BORG_KEEP_* options)
#/   - BORG_KEEP_YEARLY - defaults to 5 years
#/   - BORG_KEEP_MONTHLY - defaults to 24 months (2 years)
#/   - BORG_KEEP_WEEKLY - defaults to 52 weeks (1 year)
#/   - BORG_KEEP_DAILY - defaults to 30 days (1 month)
#/   - BORG_KEEP_HOURLY - defaults to 168 hours (7 days)
#/   - BORG_PATHS - array paths to archive, defaults to () (empty array)
#/   - and others, see http://borgbackup.readthedocs.io/en/stable/man_intro.html#environment-variables

# >>> OBB:BEGIN variant=header
################################################################################
# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################
# <<< OBB:END

################################################################################
# Clean up temporary files on script exit.
#
# Globals:
#   - _BORG_KEY_TMPDIR
################################################################################
function cleanup() {
  # Function is invoked indirectly via trap.
  # shellcheck disable=SC2317
  local -r ret=$?

  # Function is invoked indirectly via trap.
  # shellcheck disable=SC2317
  [[ -v _BORG_KEY_TMPDIR ]] && [[ -d "${_BORG_KEY_TMPDIR}" ]] && rm -rf "${_BORG_KEY_TMPDIR}"

  # Function is invoked indirectly via trap.
  # shellcheck disable=SC2317
  exit "${ret}"
}


# ------------------------------------------------------------------------------
# Clean up on script exit.
function main() {
  trap cleanup EXIT

while getopts :c:h opt; do
  case $opt in
    c)
      BORG_CONFIG_FILE="${OPTARG}"
      ;;
    h)
      usage
      die 0
      ;;
    *)
      usage 1>&2
      die 1
      ;;
  esac
done
shift "$((OPTIND-1))"

if (( $# < 1 )); then
  usage 1>&2
  die 2
fi

COMMAND="$1"
shift

# Requirements
require_command borg || die 2 "Cannot find 'borg'. Install from https://github.com/borgbackup/borg/releases"

BORG_CONFIG_FILE="${BORG_CONFIG_FILE:-/etc/borg-backup.conf}"
# Config file should be available on remote, destination system, not where shellcheck is executed.
# shellcheck disable=SC1090
[[ -r "${BORG_CONFIG_FILE}" ]] && source "${BORG_CONFIG_FILE}"

# Check if command consists few commands and we should execute script in recursion.
if [[ "${COMMAND}" == "create+prune" || "${COMMAND}" == "create+prune+check" || "${COMMAND}" == "prune+check" ]]; then
  export BORG_ARCHIVE_NAME
  export BORG_BASE_DIR
  export BORG_CHECK_I_KNOW_WHAT_I_AM_DOING
  export BORG_COMPRESSION
  export BORG_CONFIG_FILE
  export BORG_DELETE_I_KNOW_WHAT_I_AM_DOING
  export BORG_ENCRYPTION
  export BORG_FILES_CACHE_TTL
  export BORG_HOSTNAME_IS_UNIQUE
  export BORG_KEEP_DAILY
  export BORG_KEEP_HOURLY
  export BORG_KEEP_MONTHLY
  export BORG_KEEP_WEEKLY
  export BORG_KEEP_WITHIN
  export BORG_KEEP_YEARLY
  export BORG_KEY_FILE
  export BORG_LOGGING_CONF
  export BORG_LOG_FILE
  export BORG_OPTIONS_CREATE
  export BORG_OPTIONS_PRUNE
  export BORG_PASSPHRASE
  export BORG_PATHS
  export BORG_RECREATE_I_KNOW_WHAT_I_AM_DOING
  export BORG_RELOCATED_REPO_ACCESS_IS_OK
  export BORG_REMOTE_PATH
  export BORG_REPO
  export BORG_RSH
  export BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK
  export TMPDIR

  case "${COMMAND}" in
    create+prune)
      if "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" create "$@" && "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" prune "$@"; then
        RET=0
      else
        RET=$?
      fi
      ;;
    create+prune+check)
      if "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" create "$@" && "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" prune "$@" && "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" check "$@"; then
        RET=0
      else
        RET=$?
      fi
      ;;
    prune+check)
      if "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" prune "$@" && "${BASH_SOURCE[0]}" -c "${BORG_CONFIG_FILE}" check "$@"; then
        RET=0
      else
        RET=$?
      fi
      ;;
  esac
  die "${RET}"
fi

if [[ ! -v BORG_PATHS ]]; then
  BORG_PATHS=()
fi

if [[ ! -v BORG_REPO || ! -v BORG_PASSPHRASE ]]; then
  usage
  die 2
fi

if [[ "${COMMAND}" == "get-key" && $# -gt 1 ]]; then
  usage
  die 2
fi

if [[ "${COMMAND}" == "create" && $# -lt 1 && ${#BORG_PATHS[@]} -eq 0 ]]; then
  usage
  die 2
fi

if [[ "${COMMAND}" == "delete" && $# -lt 1 ]]; then
  usage
  die 2
fi

if [[ "${COMMAND}" == "extract" && $# -lt 1 ]]; then
  usage
  die 2
fi

# Defaults
BORG_ARCHIVE_NAME="${BORG_ARCHIVE_NAME:-{now:%Y-%m-%dT%H:%M:%S}}"
if [[ ! -v BORG_OPTIONS_CREATE ]]; then
  BORG_OPTIONS_CREATE=()
fi
BORG_COMPRESSION="${BORG_COMPRESSION:-lz4}"
BORG_ENCRYPTION="${BORG_ENCRYPTION:-repokey-blake2}"

BORG_LOG_FILE="${BORG_LOG_FILE:-$(date +%y%m%d-%H%M%S)-${BORG_REPO##*/}-${COMMAND}.log}"
if [[ -v BORG_BASE_DIR ]]; then
  BORG_LOG_DIR="${BORG_LOG_DIR:-${BORG_BASE_DIR}/logs}"
  BORG_LOG="${BORG_LOG_DIR}/${BORG_LOG_FILE}"

  if [[ ! -d "${BORG_LOG_DIR}" ]]; then
    # We're aware that when used with -p, -m only applies to the deepest directory.
    # shellcheck disable=SC2174
    mkdir -m 700 -p "${BORG_LOG_DIR}"
  fi

  BORG_CONFIG_DIR="${BORG_CONFIG_DIR:-${BORG_BASE_DIR}/config}"
  BORG_CACHE_DIR="${BORG_CACHE_DIR:-${BORG_BASE_DIR}/cache}"
  BORG_SECURITY_DIR="${BORG_SECURITY_DIR:-${BORG_BASE_DIR}/security}"
  BORG_KEYS_DIR="${BORG_KEYS_DIR:-${BORG_BASE_DIR}/keys}"
else
  if [[ -v BORG_LOG_DIR ]]; then
    BORG_LOG="${BORG_LOG_DIR}/${BORG_LOG_FILE}"

    if [[ ! -d "${BORG_LOG_DIR}" ]]; then
      # We're aware that when used with -p, -m only applies to the deepest directory.
      # shellcheck disable=SC2174
      mkdir -m 700 -p "${BORG_LOG_DIR}"
    fi
  else
    BORG_LOG="/dev/null"
  fi
fi

if [[ ! -v BORG_OPTIONS_PRUNE ]]; then
  BORG_OPTIONS_PRUNE=()
fi
if [[ -v BORG_KEEP_WITHIN ]]; then
  BORG_OPTIONS_PRUNE+=("--keep-within=${BORG_KEEP_WITHIN}")
else
  BORG_KEEP_YEARLY="${BORG_KEEP_YEARLY:-5}"
  BORG_KEEP_MONTHLY="${BORG_KEEP_MONTHLY:-24}"
  BORG_KEEP_WEEKLY="${BORG_KEEP_WEEKLY:-52}"
  BORG_KEEP_DAILY="${BORG_KEEP_DAILY:-30}"
  BORG_KEEP_HOURLY="${BORG_KEEP_HOURLY:-168}"
  BORG_OPTIONS_PRUNE+=("--keep-hourly=${BORG_KEEP_HOURLY}")
  BORG_OPTIONS_PRUNE+=("--keep-daily=${BORG_KEEP_DAILY}")
  BORG_OPTIONS_PRUNE+=("--keep-weekly=${BORG_KEEP_WEEKLY}")
  BORG_OPTIONS_PRUNE+=("--keep-monthly=${BORG_KEEP_MONTHLY}")
  BORG_OPTIONS_PRUNE+=("--keep-yearly=${BORG_KEEP_YEARLY}")
fi
TIMEFORMAT='
Duration: %3lR'

# General
export BORG_REPO
export BORG_PASSPHRASE

[[ -v BORG_HOSTNAME_IS_UNIQUE ]] && export BORG_HOSTNAME_IS_UNIQUE
[[ -v BORG_LOGGING_CONF ]] && export BORG_LOGGING_CONF
[[ -v BORG_RSH ]] && export BORG_RSH
[[ -v BORG_REMOTE_PATH ]] && export BORG_REMOTE_PATH
[[ -v BORG_FILES_CACHE_TTL ]] && export BORG_FILES_CACHE_TTL

# Some automatic "answers" (if set, they automatically answer confirmation questions)
[[ -v BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK ]] && export BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK
[[ -v BORG_RELOCATED_REPO_ACCESS_IS_OK ]] && export BORG_RELOCATED_REPO_ACCESS_IS_OK
[[ -v BORG_CHECK_I_KNOW_WHAT_I_AM_DOING ]] && export BORG_CHECK_I_KNOW_WHAT_I_AM_DOING
[[ -v BORG_DELETE_I_KNOW_WHAT_I_AM_DOING ]] && export BORG_DELETE_I_KNOW_WHAT_I_AM_DOING
[[ -v BORG_RECREATE_I_KNOW_WHAT_I_AM_DOING ]] && export BORG_RECREATE_I_KNOW_WHAT_I_AM_DOING

# Directories and files
[[ -v BORG_BASE_DIR ]] && export BORG_BASE_DIR
[[ -v BORG_CACHE_DIR ]] && export BORG_CACHE_DIR
[[ -v BORG_CONFIG_DIR ]] && export BORG_CONFIG_DIR
[[ -v BORG_SECURITY_DIR ]] && export BORG_SECURITY_DIR
[[ -v BORG_KEYS_DIR ]] && export BORG_KEYS_DIR
[[ -v BORG_KEY_FILE ]] && export BORG_KEY_FILE
[[ -v TMPDIR ]] && export TMPDIR

case "${COMMAND}" in
  break-lock)
    BORG=(
      break-lock
      --show-rc
      )
    ;;
  get-key)
    BORG=()
    ;;
  compact)
    BORG=(
      compact
      --show-rc
      )
    ;;
  create)
    BORG=(
      create
      --show-rc
      --stats
      --compression "${BORG_COMPRESSION}"
      --exclude lost+found
      --exclude-caches
      --exclude-if-present .NOBACKUP
      --keep-exclude-tags
      --noflags
      ${BORG_OPTIONS_CREATE[@]+"${BORG_OPTIONS_CREATE[@]}"}
      "::${BORG_ARCHIVE_NAME}"
      ${BORG_PATHS[@]+"${BORG_PATHS[@]}"}
      )
    ;;
  check)
    BORG=(
      check
      --show-rc
      --verbose
      --progress
      )
    ;;
  delete)
    BORG=(
      delete
      --show-rc
      --stats
      )
    ;;
  extract)
    BORG=(
      extract
      --show-rc
      --list
      --sparse
      --progress
      )
    ;;
  info)
    BORG=(
      info
      --show-rc
      )
    ;;
  init)
    BORG=(
      init
      --show-rc
      "--encryption=${BORG_ENCRYPTION}"
      )
    ;;
  list)
    BORG=(
      list
      --show-rc
      )
    ;;
  prune)
    BORG=(
      prune
      --show-rc
      --stats
      --list
      --verbose
      ${BORG_OPTIONS_PRUNE[@]+"${BORG_OPTIONS_PRUNE[@]}"}
      )
    ;;
  recreate)
    BORG=(
      recreate
      --show-rc
      --stats
      --compression "${BORG_COMPRESSION}"
      --recompress
      --exclude lost+found
      --exclude-caches
      --exclude-if-present .NOBACKUP
      --keep-exclude-tags
      ${BORG_OPTIONS_CREATE[@]+"${BORG_OPTIONS_CREATE[@]}"}
      )
    ;;
  with-lock)
    BORG=(
      with-lock
      --show-rc
      )
    ;;
  *) usage 1>&2
     die 1
     ;;
esac


if [[ ${#BORG[@]} -ne 0 ]]; then
  BORG+=("$@")
  {
    print "Start: $(date)"
    print "Borg version: $(borg --version)"
    print "Environment:"
    set | grep ^BORG_ | grep -v ^BORG_PASSPHRASE | while read -r v; do print "  ${v}"; done
    print "  BORG_PASSPHRASE=**PROTECTED**"
    (IFS=' ' print "Executing: borg" "${BORG[@]}")
    print
    if time borg "${BORG[@]}"; then
      RET=0
    else
      RET=$?
    fi
    print "End: $(date)"
    print "Exit code: $RET"
  } &> >(tee "${BORG_LOG}")
else
  case "${COMMAND}" in
    get-key)
      _BORG_KEY_TMPDIR="$(mktemp -d)"
      set +e
      borg key export "${BORG_REPO}" "${_BORG_KEY_TMPDIR}/key" 2>&1
      RET=$?
      set -e

      install -m 600 /dev/null "${_BORG_KEY_TMPDIR}/info"
      echo "--------------------------------------------------------------------------------" >> "${_BORG_KEY_TMPDIR}/info"
      if ! borg info | grep -E '^(Repository ID|Location|Encrypted|Cache|Security dir): ' &>> "${_BORG_KEY_TMPDIR}/info"; then
        :
      fi
      if [[ -e "${_BORG_KEY_TMPDIR}/key" ]]; then
        echo "--------------------------------------------------------------------------------" >> "${_BORG_KEY_TMPDIR}/info"
        cat "${_BORG_KEY_TMPDIR}/key" >> "${_BORG_KEY_TMPDIR}/info"
      fi
      echo "--------------------------------------------------------------------------------" >> "${_BORG_KEY_TMPDIR}/info"
      echo "BORG_PASSPHRASE ${BORG_PASSPHRASE}" >> "${_BORG_KEY_TMPDIR}/info"
      echo "--------------------------------------------------------------------------------" >> "${_BORG_KEY_TMPDIR}/info"
      echo >> "${_BORG_KEY_TMPDIR}/info"
      echo "You will need both BORG_KEY and BORG_PASSPHRASE to access this repo! Store both at safe place(s)." >> "${_BORG_KEY_TMPDIR}/info"

      if [[ $# == 1 && $RET -eq 0 ]]; then
        mv "${_BORG_KEY_TMPDIR}/info" "${1}"
      else
        cat "${_BORG_KEY_TMPDIR}/info"
      fi
      ;;
  esac
fi

die "${RET}"
}

# >>> OBB:BEGIN variant=full source=local version=local
# SPDX-FileCopyrightText: 2016-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
#
# Specify the shell for ShellCheck since we do not use a shebang here
# shellcheck shell=bash

################################################################################
# Define colors and formatting
#
# Define colors ANSI 4-bit colors
#   - https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
#   - https://misc.flogisoft.com/bash/tip_colors_and_formatting
#   - https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
#   - https://superuser.com/q/301353
################################################################################

# \x1b (ESC Escape) is hex equivalent of Bash '\e' that can be used more widely.
# Foreground                         # Background
readonly __c_black=$'\x1b[0;30m';    readonly __c_b_black=$'\x1b[0;40m'    #  0. Black
readonly __c_red=$'\x1b[0;31m';      readonly __c_b_red=$'\x1b[0;41m'      #  1. Red
readonly __c_green=$'\x1b[0;32m';    readonly __c_b_green=$'\x1b[0;42m'    #  2. Green
readonly __c_yellow=$'\x1b[0;33m';   readonly __c_b_yellow=$'\x1b[0;43m'   #  3. Yellow
readonly __c_blue=$'\x1b[0;34m';     readonly __c_b_blue=$'\x1b[0;44m'     #  4. Blue
readonly __c_magenta=$'\x1b[0;35m';  readonly __c_b_magenta=$'\x1b[0;45m'  #  5. Magenta
readonly __c_cyan=$'\x1b[0;36m';     readonly __c_b_cyan=$'\x1b[0;46m'     #  6. Cyan
readonly __c_white=$'\x1b[0;37m';    readonly __c_b_white=$'\x1b[0;47m'    #  7. White
readonly __c_grey=$'\x1b[1;30m';     readonly __c_b_grey=$'\x1b[1;40m'     #  8. Bright Black (Grey)
readonly __c_bred=$'\x1b[1;31m';     readonly __c_b_bred=$'\x1b[1;41m'     #  9. Bright Red
readonly __c_bgreen=$'\x1b[1;32m';   readonly __c_b_bgreen=$'\x1b[1;42m'   # 10. Bright Green
readonly __c_byellow=$'\x1b[1;33m';  readonly __c_b_byellow=$'\x1b[1;43m'  # 11. Bright Yellow
readonly __c_bblue=$'\x1b[1;34m';    readonly __c_b_bblue=$'\x1b[1;44m'    # 12. Bright Blue
readonly __c_bmagenta=$'\x1b[1;35m'; readonly __c_b_bmagenta=$'\x1b[1;45m' # 13. Bright Magenta
readonly __c_bcyan=$'\x1b[1;36m';    readonly __c_b_bcyan=$'\x1b[1;46m'    # 14. Bright Cyan
readonly __c_bwhite=$'\x1b[1;37m';   readonly __c_b_bwhite=$'\x1b[1;47m'   # 15. Bright White
readonly __c_default=$'\x1b[0;39m';  readonly __c_b_default=$'\x1b[0;49m'  # Default color

readonly __c_bld=$'\x1b[1m'     # Bold text
readonly __c_und=$'\x1b[4m'     # Underline text
readonly __c_inv=$'\x1b[7m'     # Inverse: swap background and foreground colors
readonly __c_reg=$'\x1b[22;24m' # Regular text only, keep colors
readonly __c_rst=$'\x1b[0m'     # Reset all attributes

readonly __c_error="${__c_red}"
readonly __c_warning="${__c_yellow}"
readonly __c_ok="${__c_green}"

################################################################################
# Print help message
#
# Usage: usage
#
# Outputs: Help message defined in the script code, prefixed with '#/'
################################################################################
function usage() {
  # __my_path is assigned in script that includes this library
  # shellcheck disable=SC2154
  printf "%b\n" "$(grep '^#/' "${__my_path}" | cut -c4-)" 1>&2
}

################################################################################
# Output current timestamp in ISO 8601 format (2020-02-11T08:56:00+0000) to stdout
#
# Usage: now
#        echo "$(now)"
#
# Outputs: timestamp
################################################################################
function now() {
  printf '%(%Y-%m-%dT%H:%M:%S%z)T' -1
}

################################################################################
# Read lines from stdin and call a function for each line
#
# Usage: __read_stdin_lines <function_name>
#
# Outputs: None
# Returns: 0 when stdin is piped and all calls succeed, 1 otherwise
################################################################################
function __read_stdin_lines() {
  local func="$1" line
  shift
  (($# == 0)) && [[ -p /dev/stdin ]] || return 1
  # No arguments and stdin is opened, so read message from stdin and execute the function for each line
  while read -r line; do "${func}" "${line}"; done
}

################################################################################
# Output timestamp and message to stdout
#
# Usage: echo "message to print on stdout" | print
#        print [message to print on stdout]
#
# Outputs: timestamp and message
################################################################################
function print() {
  __read_stdin_lines print "$@" && return
  printf '%s %b\n' "$(now)" "$*"
}

################################################################################
# Print error message to stderr
#
# Usage: echo "message to print on stderr" | error
#        error [message to print on stderr]
#
# Outputs: message
################################################################################
function error() {
  __read_stdin_lines error "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_error}ERROR: $*${__c_rst}" 1>&2; else print "ERROR: $*" 1>&2; fi
}

################################################################################
# Print warning message to stderr
#
# Usage: echo "message to print on stderr" | warning
#        warning [message to print on stderr]
#
# Outputs: message
################################################################################
function warning() {
  __read_stdin_lines warning "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_warning}WARN: $*${__c_rst}" 1>&2; else print "WARN: $*" 1>&2; fi
}

################################################################################
# Print OK message to stdout
#
# Usage: echo "message to print on stdout" | ok
#        ok [message to print on stdout]
#
# Outputs: message
################################################################################
function ok() {
  __read_stdin_lines ok "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_ok}OK: $*${__c_rst}"; else print "OK: $*"; fi
}

################################################################################
# Print a bigger header to stdout
#
# Usage: echo "header to print on stdout" | header
#        header [header to print on stdout]
#
# Outputs: header
################################################################################
function header() {
  __read_stdin_lines header "$@" && return
  print "##########"; print "# $*"; print "##########"
}

################################################################################
# Show a rotating spinner on stdout
#
# Based on https://mywiki.wooledge.org/BashFAQ/034 and vendored 1-char spinners
# from https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json
#
# Usage: spin [spinner_name, defaults to 'dots'] &
#        spin_pid=$!
#        # long-running commands here
#        kill "${spin_pid}"; wait "${spin_pid}" 2>/dev/null
#
# Outputs: spinner animation
################################################################################
function spin() {
  local spinner="${1:-dots}"
  local i=0
  local sp=''
  local n=0
  local tty_fd=0
  local locale="${LC_ALL:-${LC_CTYPE:-${LANG:-}}}"

  if [[ ${locale^^} != *UTF-8* && ${locale^^} != *UTF8* ]]; then
    spinner='line'
  fi

  case "${spinner}" in
    dots) sp='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏' ;;
    dots2) sp='⣾⣽⣻⢿⡿⣟⣯⣷' ;;
    sand) sp='⠁⠂⠄⡀⡈⡐⡠⣀⣁⣂⣄⣌⣔⣤⣥⣦⣮⣶⣷⣿⡿⠿⢟⠟⡛⠛⠫⢋⠋⠍⡉⠉⠑⠡⢁' ;;
    line) sp='-\|/' ;;
    dqpb) sp='dqpb' ;;
    *) sp='-\|/' ;;
  esac

  n=${#sp}
  printf ' '
  { exec {tty_fd}</dev/tty; } 2>/dev/null || return 0
  while :; do
    printf '\b%s' "${sp:i++%n:1}"
    IFS= read -r -t 0.1 -u "${tty_fd}" || true
  done
}

################################################################################
# Print an optional message and exit with either the given status or that of the most recent command
#
# Based on https://mywiki.wooledge.org/BashFAQ/101
#
# Usage: some_command || die [status code] [message to print on exit]
#        die [status code] [message to print on exit]
#
# Outputs: message
################################################################################
function die() {
  # Get the exit code of the most recent command.
  local ret=$?

  # At least one argument and it is a number, use as an exit code
  if (( $# > 0 )) && [[ $1 =~ ^[0-9]+$ ]]; then ret="$1"; shift; fi

  # Still at least one argument, use all of them as a message
  if (( $# > 0 )); then if (( ret != 0 )); then error "$*"; else print "$*"; fi; fi
  exit "${ret}"
}

################################################################################
# Check if this instance of bash version is at least X.Y
#
# Usage: require_bash_version [major] [minor]
#        require_bash_version 4 4 || die 2 "At least Bash 4.4 is required"
#
# Returns: 0 if bash version is at least required; 1 if bash version is older
################################################################################
function require_bash_version() {
  (( BASH_VERSINFO[0] > $1 || (BASH_VERSINFO[0] == $1 && BASH_VERSINFO[1] >= $2) ))
}

################################################################################
# Check if required command is available
#
# Usage: require_command [required command] || die 2 "Cannot find 'X'. Install 'xxx' package"
#        require_command [required command] || die 2
#
# Returns: 0 if required command is available; 1 if required command is not available
################################################################################
function require_command() {
  type -P "$1" > /dev/null
}

################################################################################
# Check if script is being run by root user
#
# Usage: require_root || die 2 "This script must be run as root"
#        require_root && die 2 "This script must not be run as root"
#
# Returns: 0 if being run as root; 1 if not being run as root
################################################################################
function require_root() {
  (( EUID == 0 ))
}

################################################################################
# Check if script is piped
#
# Usage: is_piped
#
# Returns: 0 if output is piped; 1 if output is not piped
################################################################################
function is_piped() {
  [[ ! -t 1 ]]
}

################################################################################
# Check if script is sourced
#
# Usage: is_sourced
#
# Returns: 0 if being sourced; 1 if not being sourced
#################################################################################
function is_sourced() {
  [[ "${BASH_SOURCE[0]}" != "$0" ]]
}

################################################################################
# Check if script is interactive
#
# Based on https://mywiki.wooledge.org/BashFAQ/109
#
# Usage: is_interactive
#
# Returns: 0 if interactive; 1 if not interactive
#################################################################################
function is_interactive() {
  [[ $- == *i* || -t 0 ]]
}

# Minimum supported Bash version for Octivi Bash Boilerplate is Bash 4.4
require_bash_version 4 4 || { echo "At least Bash 4.4 is required"; is_sourced && return 2 || exit 2; }

# Disable colors if script is piped
if is_piped; then
  NO_COLOR=1
fi

# Run main only when executed directly; do nothing when sourced.
if ! is_sourced; then
  main "$@"
fi
# <<< OBB:END
